# ğŸ§  AI ç¾¤èŠäº’åŠ¨ç³»ç»Ÿ - æ™ºèƒ½ç¼–æ’è®¾è®¡æ–¹æ¡ˆ

## æ ¸å¿ƒç†å¿µ

**è®©AIç¼–æ’AIï¼Œåˆ›é€ çœŸæ­£è‡ªç„¶çš„ç¾¤èŠä½“éªŒ**

ä¸é¢„è®¾å›ºå®šæ¨¡å¼ï¼Œè€Œæ˜¯é€šè¿‡æ™ºèƒ½åˆ†æå’ŒåŠ¨æ€ç¼–æ’ï¼Œè®©AIä»¬æ ¹æ®å®æ—¶åœºæ™¯è‡ªä¸»å†³å®šå¦‚ä½•å‚ä¸å¯¹è¯ï¼š

- **æ™ºèƒ½ä½“ä¿æŒåŸæœ‰ä¸ªæ€§** - æ¯ä¸ªAIçš„æ ¸å¿ƒç‰¹è‰²ä¸å˜
- **AIè‡ªä¸»åˆ¤æ–­åœºæ™¯** - åœºæ™¯åˆ†æAIå®æ—¶ç†è§£å¯¹è¯æƒ…å¢ƒ  
- **åŠ¨æ€ç”Ÿæˆæç¤ºè¯** - æ ¹æ®åœºæ™¯æ™ºèƒ½æ‰©å±•æç¤ºè¯
- **è‡ªç„¶ç¾¤èŠä½“éªŒ** - æ— è§„åˆ™æŸç¼šï¼Œå®Œå…¨è‡ªç”±å¯¹è¯

## ä¸€ã€ç³»ç»Ÿæ¶æ„è®¾è®¡

### 1.1 æ•´ä½“æ¶æ„æµç¨‹

```
ç”¨æˆ·æ¶ˆæ¯è¾“å…¥
    â†“
ã€åœºæ™¯åˆ†æAIã€‘åˆ†æå½“å‰æƒ…å¢ƒå’Œä¸Šä¸‹æ–‡
    â†“
ã€ç¼–æ’å†³ç­–AIã€‘å†³å®šå“ªäº›æ™ºèƒ½ä½“å‚ä¸ï¼Œå¦‚ä½•å‚ä¸
    â†“
ã€æç¤ºè¯å·¥å‚ã€‘ä¸ºæ¯ä¸ªå‚ä¸çš„æ™ºèƒ½ä½“åŠ¨æ€ç”Ÿæˆåœºæ™¯æ‰©å±•æç¤ºè¯
    â†“
ã€æ™ºèƒ½ä½“è°ƒåº¦å™¨ã€‘åè°ƒå¤šä¸ªAIçš„å›å¤é¡ºåºå’Œæ—¶æœº
    â†“
ã€ç¾¤èŠä½“éªŒç”Ÿæˆã€‘æœ€ç»ˆçš„è‡ªç„¶å¯¹è¯è¾“å‡º
```

### 1.2 æ ¸å¿ƒç»„ä»¶

#### A. åœºæ™¯åˆ†æAI (Scene Analyzer)
**èŒè´£**: å®æ—¶ç†è§£å¯¹è¯åœºæ™¯å’Œç”¨æˆ·æ„å›¾
```
è¾“å…¥: ç”¨æˆ·æ¶ˆæ¯ + å†å²å¯¹è¯ + å½“å‰å‚ä¸è€…
è¾“å‡º: åœºæ™¯æ ‡ç­¾ + æƒ…æ„ŸçŠ¶æ€ + äº’åŠ¨å»ºè®®

åœºæ™¯ç±»å‹ç¤ºä¾‹:
- casual_chat: æ—¥å¸¸é—²èŠ
- emotional_support: æƒ…æ„Ÿæ”¯æŒ  
- work_discussion: å·¥ä½œè®¨è®º
- problem_solving: é—®é¢˜è§£å†³
- creative_brainstorm: åˆ›æ„å¤´è„‘é£æš´
- debate_discussion: äº‰è®ºè®¨è®º
- humor_entertainment: å¨±ä¹æç¬‘
```

#### B. ç¼–æ’å†³ç­–AI (Orchestration Director)
**èŒè´£**: å†³å®šç¾¤èŠçš„æ•´ä½“èŠ‚å¥å’Œå‚ä¸ç­–ç•¥
```
è¾“å…¥: åœºæ™¯åˆ†æç»“æœ + å¯ç”¨æ™ºèƒ½ä½“åˆ—è¡¨ + ç¾¤èŠå†å²
è¾“å‡º: å‚ä¸è®¡åˆ’ + äº’åŠ¨ç­–ç•¥ + èŠ‚å¥æ§åˆ¶

å†³ç­–ç»´åº¦:
- å‚ä¸è€…é€‰æ‹©: å“ªäº›AIåº”è¯¥å‚ä¸
- å‚ä¸é¡ºåº: è°å…ˆè¯´è¯ï¼Œè°åè¯´è¯
- äº’åŠ¨æ·±åº¦: æ˜¯å¦éœ€è¦å¤šè½®å¯¹è¯
- èŠ‚å¥æ§åˆ¶: å›å¤é—´éš”å’Œå¯¹è¯æŒç»­æ—¶é—´
- å†²çªç®¡ç†: å¦‚ä½•å¤„ç†è§‚ç‚¹åˆ†æ­§
```

#### C. æç¤ºè¯å·¥å‚ (Dynamic Prompt Factory)
**èŒè´£**: ä¸ºæ¯ä¸ªæ™ºèƒ½ä½“åŠ¨æ€ç”Ÿæˆåœºæ™¯ç›¸å…³çš„æç¤ºè¯æ‰©å±•
```
è¾“å…¥: æ™ºèƒ½ä½“åŸºç¡€é…ç½® + åœºæ™¯ä¿¡æ¯ + å‚ä¸è§’è‰²
è¾“å‡º: å®Œæ•´çš„åŠ¨æ€æç¤ºè¯

æç¤ºè¯æ„æˆ:
åŸºç¡€æ™ºèƒ½ä½“Prompt + åœºæ™¯æ‰©å±• + è§’è‰²å®šä½ + äº’åŠ¨æŒ‡å¼• + çº¦æŸæ¡ä»¶

ç¤ºä¾‹ç”Ÿæˆé€»è¾‘:
if scene == "emotional_support":
  add_empathy_instructions()
  add_gentle_tone_guide()
  add_supportive_response_examples()
elif scene == "work_discussion":
  add_professional_tone()
  add_solution_focus()
  add_collaboration_emphasis()
```

#### D. æ™ºèƒ½ä½“è°ƒåº¦å™¨ (Agent Scheduler)
**èŒè´£**: åè°ƒå¤šä¸ªAIçš„å®é™…æ‰§è¡Œå’Œæ—¶åºæ§åˆ¶
```
åŠŸèƒ½:
- å¹¶å‘æ§åˆ¶: ç®¡ç†åŒæ—¶è¯´è¯çš„AIæ•°é‡
- æ—¶åºæ§åˆ¶: æ§åˆ¶å›å¤çš„æ—¶é—´é—´éš”
- å†²çªé¿å…: é˜²æ­¢AIé‡å¤æˆ–çŸ›ç›¾å›å¤
- è´¨é‡ä¿è¯: ç¡®ä¿å›å¤è´¨é‡å’Œç›¸å…³æ€§
```

### 1.3 æ•°æ®ç»“æ„è®¾è®¡

#### æ ¸å¿ƒæ•°æ®è¡¨
```sql
-- åœºæ™¯åˆ†æè®°å½•
CREATE TABLE scene_analyses (
  id STRING PRIMARY KEY,
  conversation_id STRING,
  message_id STRING,
  scene_type VARCHAR(50),
  emotional_state VARCHAR(30),
  topics JSON, -- æå–çš„è¯é¢˜æ ‡ç­¾
  participants_suggestion JSON, -- å»ºè®®å‚ä¸çš„AI
  confidence_score FLOAT,
  created_at TIMESTAMP
);

-- ç¼–æ’å†³ç­–è®°å½•  
CREATE TABLE orchestration_plans (
  id STRING PRIMARY KEY,
  scene_analysis_id STRING,
  selected_agents JSON, -- é€‰ä¸­çš„AIåˆ—è¡¨
  interaction_strategy VARCHAR(50), -- äº’åŠ¨ç­–ç•¥
  expected_rounds INT, -- é¢„æœŸè½®æ¬¡
  timing_plan JSON, -- æ—¶åºå®‰æ’
  created_at TIMESTAMP
);

-- åŠ¨æ€æç¤ºè¯ç¼“å­˜
CREATE TABLE dynamic_prompts (
  id STRING PRIMARY KEY,
  agent_id STRING,
  scene_type VARCHAR(50),
  base_prompt TEXT,
  scene_extensions TEXT, -- åœºæ™¯æ‰©å±•
  role_instructions TEXT, -- è§’è‰²æŒ‡å¼•
  constraints TEXT, -- çº¦æŸæ¡ä»¶
  generated_at TIMESTAMP,
  usage_count INT
);

-- æ™ºèƒ½ä½“è¡¨æ‰©å±•
ALTER TABLE Agent ADD COLUMN flexibility_score INT DEFAULT 7; -- é€‚åº”æ€§è¯„åˆ†(1-10)
ALTER TABLE Agent ADD COLUMN interaction_patterns JSON; -- äº’åŠ¨åå¥½
ALTER TABLE Agent ADD COLUMN performance_metrics JSON; -- è¡¨ç°æŒ‡æ ‡
```

## äºŒã€æ™ºèƒ½åˆ†æä¸å†³ç­–é€»è¾‘

### 2.1 åœºæ™¯åˆ†æAIå®ç°

#### åœºæ™¯è¯†åˆ«ç®—æ³•
```typescript
class SceneAnalyzer {
  async analyzeScene(
    userMessage: string, 
    conversationHistory: Message[],
    availableAgents: Agent[]
  ): Promise<SceneAnalysisResult> {
    
    // 1. å¤šç»´åº¦åˆ†æ
    const emotionalContext = await this.analyzeEmotion(userMessage, conversationHistory);
    const topicContext = await this.extractTopics(userMessage);
    const intentContext = await this.analyzeIntent(userMessage);
    const socialContext = await this.analyzeSocialDynamics(conversationHistory);
    
    // 2. åœºæ™¯ç»¼åˆåˆ¤æ–­
    const sceneType = await this.determineSceneType({
      emotionalContext,
      topicContext,  
      intentContext,
      socialContext
    });
    
    // 3. å‚ä¸å»ºè®®ç”Ÿæˆ
    const participationSuggestions = await this.generateParticipationPlan(
      sceneType, 
      availableAgents,
      conversationHistory
    );
    
    return {
      sceneType,
      emotionalState: emotionalContext.primary,
      topics: topicContext.topics,
      socialDynamics: socialContext,
      participationPlan: participationSuggestions,
      confidenceScore: this.calculateConfidence()
    };
  }
  
  private async determineSceneType(contexts: any): Promise<string> {
    // ä½¿ç”¨LLMè¿›è¡Œç»¼åˆåˆ†æ
    const prompt = `
åŸºäºä»¥ä¸‹ä¸Šä¸‹æ–‡ä¿¡æ¯ï¼Œåˆ¤æ–­å½“å‰å¯¹è¯åœºæ™¯ï¼š

æƒ…æ„Ÿä¸Šä¸‹æ–‡: ${JSON.stringify(contexts.emotionalContext)}
è¯é¢˜ä¸Šä¸‹æ–‡: ${JSON.stringify(contexts.topicContext)}
æ„å›¾ä¸Šä¸‹æ–‡: ${JSON.stringify(contexts.intentContext)}
ç¤¾äº¤åŠ¨æ€: ${JSON.stringify(contexts.socialContext)}

è¯·ä»ä»¥ä¸‹åœºæ™¯ç±»å‹ä¸­é€‰æ‹©æœ€åˆé€‚çš„1-2ä¸ªï¼š
- casual_chat: æ—¥å¸¸é—²èŠ
- emotional_support: æƒ…æ„Ÿæ”¯æŒ
- work_discussion: å·¥ä½œè®¨è®º  
- problem_solving: é—®é¢˜è§£å†³
- creative_brainstorm: åˆ›æ„å¤´è„‘é£æš´
- debate_discussion: äº‰è®ºè®¨è®º
- humor_entertainment: å¨±ä¹æç¬‘
- learning_discussion: å­¦ä¹ è®¨è®º
- personal_sharing: ä¸ªäººåˆ†äº«

è¿”å›JSONæ ¼å¼: {
  "primary_scene": "ä¸»è¦åœºæ™¯",
  "secondary_scene": "æ¬¡è¦åœºæ™¯æˆ–null",
  "confidence": 0.85,
  "reasoning": "åˆ¤æ–­ç†ç”±"
}
`;
    
    return await this.callLLM(prompt);
  }
}
```

### 2.2 ç¼–æ’å†³ç­–AIå®ç°

#### æ™ºèƒ½ä½“é€‰æ‹©å’Œè°ƒåº¦ç®—æ³•
```typescript
class OrchestrationDirector {
  async createOrchestrationPlan(
    sceneAnalysis: SceneAnalysisResult,
    availableAgents: Agent[],
    conversationHistory: Message[]
  ): Promise<OrchestrationPlan> {
    
    // 1. æ™ºèƒ½ä½“åŒ¹é…åº¦è®¡ç®—
    const agentScores = await this.calculateAgentRelevance(
      sceneAnalysis, 
      availableAgents, 
      conversationHistory
    );
    
    // 2. ç¾¤èŠç­–ç•¥åˆ¶å®š
    const interactionStrategy = await this.designInteractionStrategy(
      sceneAnalysis,
      agentScores
    );
    
    // 3. æ—¶åºè§„åˆ’
    const timingPlan = await this.createTimingPlan(
      interactionStrategy,
      agentScores
    );
    
    return {
      selectedAgents: agentScores.filter(s => s.shouldParticipate),
      interactionStrategy,
      timingPlan,
      expectedQuality: this.estimateQuality(agentScores, interactionStrategy)
    };
  }
  
  private async calculateAgentRelevance(
    scene: SceneAnalysisResult,
    agents: Agent[],
    history: Message[]
  ): Promise<AgentScore[]> {
    
    return Promise.all(agents.map(async agent => {
      // ä½¿ç”¨LLMè¯„ä¼°æ¯ä¸ªæ™ºèƒ½ä½“çš„å‚ä¸ä»·å€¼
      const evaluationPrompt = `
æ™ºèƒ½ä½“ä¿¡æ¯:
- åç§°: ${agent.name}
- è§’è‰²: ${agent.roleTag}  
- ä¸ªæ€§: ${agent.systemPrompt.substring(0, 200)}...
- å†å²è¡¨ç°: ${this.getAgentPerformanceHistory(agent.id)}

å½“å‰åœºæ™¯:
- åœºæ™¯ç±»å‹: ${scene.sceneType}
- æƒ…æ„ŸçŠ¶æ€: ${scene.emotionalState}
- è¯é¢˜: ${scene.topics.join(', ')}
- å¯¹è¯å†å²: ${this.summarizeHistory(history)}

è¯·è¯„ä¼°è¯¥æ™ºèƒ½ä½“åœ¨æ­¤åœºæ™¯ä¸‹çš„å‚ä¸ä»·å€¼:
1. ç›¸å…³æ€§å¾—åˆ† (0-10): è¯¥AIçš„ä¸“é•¿ä¸åœºæ™¯çš„åŒ¹é…åº¦
2. è´¡çŒ®æ½œåŠ› (0-10): èƒ½ä¸ºå¯¹è¯å¸¦æ¥çš„ä»·å€¼
3. äº’åŠ¨å¿…è¦æ€§ (0-10): æ˜¯å¦å¿…é¡»å‚ä¸æ­¤è½®å¯¹è¯
4. ä¸ªæ€§åŒ¹é…åº¦ (0-10): ä¸ªæ€§ç‰¹è‰²æ˜¯å¦é€‚åˆå½“å‰æ°›å›´

è¿”å›JSON: {
  "relevance_score": 8,
  "contribution_potential": 7,
  "participation_necessity": 6,
  "personality_fit": 9,
  "overall_score": 7.5,
  "should_participate": true,
  "participation_timing": "immediate/delayed/conditional",
  "expected_role": "ä¸»è¦å‘è¨€è€…/æ”¯æŒè€…/è°ƒèŠ‚è€…/è§‚å¯Ÿè€…",
  "reasoning": "è¯„ä¼°ç†ç”±"
}
`;
      
      const evaluation = await this.callLLM(evaluationPrompt);
      return {
        agent,
        ...evaluation,
        calculatedAt: new Date()
      };
    }));
  }
}
```

### 2.3 åŠ¨æ€æç¤ºè¯å·¥å‚

#### æç¤ºè¯åŠ¨æ€ç”Ÿæˆé€»è¾‘
```typescript
class DynamicPromptFactory {
  async generatePrompt(
    agent: Agent,
    sceneAnalysis: SceneAnalysisResult,
    orchestrationPlan: OrchestrationPlan,
    groupContext: GroupChatContext
  ): Promise<string> {
    
    // 1. åŸºç¡€æç¤ºè¯
    let prompt = agent.systemPrompt;
    
    // 2. åœºæ™¯é€‚é…æ‰©å±•
    const sceneExtension = await this.generateSceneExtension(
      sceneAnalysis.sceneType,
      sceneAnalysis.emotionalState,
      sceneAnalysis.topics
    );
    
    // 3. è§’è‰²å®šä½æ‰©å±•  
    const roleExtension = await this.generateRoleExtension(
      orchestrationPlan.getAgentRole(agent.id),
      orchestrationPlan.interactionStrategy
    );
    
    // 4. ç¾¤èŠä¸Šä¸‹æ–‡æ‰©å±•
    const contextExtension = await this.generateContextExtension(
      groupContext.recentMessages,
      groupContext.activeParticipants,
      groupContext.conversationFlow
    );
    
    // 5. åŠ¨æ€çº¦æŸå’ŒæŒ‡å¼•
    const constraintsExtension = await this.generateConstraints(
      sceneAnalysis,
      orchestrationPlan,
      groupContext
    );
    
    // 6. æ™ºèƒ½ç»„åˆ
    const finalPrompt = await this.intelligentCombine([
      prompt,
      sceneExtension,
      roleExtension,
      contextExtension,
      constraintsExtension
    ]);
    
    return this.optimizePrompt(finalPrompt);
  }
  
  private async generateSceneExtension(
    sceneType: string,
    emotionalState: string,
    topics: string[]
  ): Promise<string> {
    
    const extensionPrompt = `
å½“å‰åœºæ™¯: ${sceneType}
æƒ…æ„Ÿæ°›å›´: ${emotionalState}  
è¯é¢˜èŒƒå›´: ${topics.join(', ')}

ä¸ºæ™ºèƒ½ä½“ç”Ÿæˆé€‚åˆæ­¤åœºæ™¯çš„è¡Œä¸ºæŒ‡å¼•ï¼Œè¦æ±‚:
1. ç¬¦åˆåœºæ™¯ç‰¹ç‚¹çš„å›åº”æ–¹å¼
2. ä¸æƒ…æ„Ÿæ°›å›´ç›¸åŒ¹é…çš„è¯­æ°”
3. å›´ç»•è¯é¢˜èŒƒå›´çš„å†…å®¹å»ºè®®
4. è‡ªç„¶çš„ç¾¤èŠäº’åŠ¨æ–¹å¼

ç”Ÿæˆ50-100å­—çš„ç®€æ´æŒ‡å¼•:
`;
    
    return await this.callLLM(extensionPrompt);
  }
  
  private async intelligentCombine(promptParts: string[]): Promise<string> {
    // ä½¿ç”¨LLMæ™ºèƒ½ç»„åˆå¤šä¸ªæç¤ºè¯ç‰‡æ®µ
    const combinePrompt = `
è¯·å°†ä»¥ä¸‹æç¤ºè¯ç‰‡æ®µæ™ºèƒ½ç»„åˆæˆä¸€ä¸ªè¿è´¯çš„å®Œæ•´æç¤ºè¯:

${promptParts.map((part, i) => `ç‰‡æ®µ${i+1}: ${part}`).join('\n\n')}

è¦æ±‚:
1. ä¿æŒé€»è¾‘ä¸€è‡´æ€§
2. é¿å…é‡å¤å†…å®¹
3. ç¡®ä¿æŒ‡å¼•æ¸…æ™°
4. è¯­è¨€è‡ªç„¶æµç•…
5. é•¿åº¦æ§åˆ¶åœ¨300-500å­—

è¿”å›ç»„åˆåçš„å®Œæ•´æç¤ºè¯:
`;
    
    return await this.callLLM(combinePrompt);
  }
}
```

## ä¸‰ã€ç³»ç»Ÿå·¥ä½œæµç¨‹

### 3.1 å®Œæ•´å¤„ç†æµç¨‹

```typescript
class IntelligentGroupChatOrchestrator {
  async processUserMessage(
    conversationId: string,
    userMessage: string,
    onEvent: (event: any) => void
  ): Promise<void> {
    
    try {
      // ç¬¬ä¸€æ­¥: åœºæ™¯åˆ†æ
      onEvent({ type: 'scene_analysis_started' });
      const sceneAnalysis = await this.sceneAnalyzer.analyzeScene(
        userMessage,
        this.getConversationHistory(conversationId),
        this.getAvailableAgents(conversationId)
      );
      onEvent({ type: 'scene_analysis_completed', scene: sceneAnalysis });
      
      // ç¬¬äºŒæ­¥: ç¼–æ’å†³ç­–
      onEvent({ type: 'orchestration_planning_started' });
      const orchestrationPlan = await this.orchestrationDirector.createOrchestrationPlan(
        sceneAnalysis,
        this.getAvailableAgents(conversationId),
        this.getConversationHistory(conversationId)
      );
      onEvent({ type: 'orchestration_planning_completed', plan: orchestrationPlan });
      
      // ç¬¬ä¸‰æ­¥: æ™ºèƒ½ä½“è°ƒåº¦æ‰§è¡Œ
      await this.executeOrchestrationPlan(
        conversationId,
        sceneAnalysis,
        orchestrationPlan,
        onEvent
      );
      
    } catch (error) {
      onEvent({ type: 'orchestration_failed', error: error.message });
    }
  }
  
  private async executeOrchestrationPlan(
    conversationId: string,
    sceneAnalysis: SceneAnalysisResult,
    plan: OrchestrationPlan,
    onEvent: (event: any) => void
  ): Promise<void> {
    
    const groupContext = new GroupChatContext(conversationId);
    
    // æŒ‰ç…§è®¡åˆ’æ‰§è¡Œå¤šè½®äº’åŠ¨
    for (const round of plan.rounds) {
      onEvent({ type: 'round_started', round: round.number });
      
      // å¹¶å‘æˆ–ä¸²è¡Œæ‰§è¡Œè¯¥è½®çš„æ™ºèƒ½ä½“
      if (round.executionMode === 'parallel') {
        await this.executeParallelRound(round, sceneAnalysis, groupContext, onEvent);
      } else {
        await this.executeSequentialRound(round, sceneAnalysis, groupContext, onEvent);
      }
      
      // è½®æ¬¡é—´æš‚åœå’Œä¸Šä¸‹æ–‡æ›´æ–°
      await this.pauseBetweenRounds(round.pauseDuration);
      groupContext.updateAfterRound(round);
      
      onEvent({ type: 'round_completed', round: round.number });
    }
    
    onEvent({ type: 'orchestration_completed' });
  }
  
  private async executeAgent(
    agent: Agent,
    sceneAnalysis: SceneAnalysisResult,
    plan: OrchestrationPlan,
    groupContext: GroupChatContext,
    onEvent: (event: any) => void
  ): Promise<void> {
    
    // ç”ŸæˆåŠ¨æ€æç¤ºè¯
    const dynamicPrompt = await this.promptFactory.generatePrompt(
      agent,
      sceneAnalysis,
      plan,
      groupContext
    );
    
    // æ„å»ºæ¶ˆæ¯
    const messages = [
      { role: 'system', content: dynamicPrompt },
      { role: 'user', content: this.buildUserInput(groupContext) }
    ];
    
    // æ‰§è¡ŒAIè°ƒç”¨
    onEvent({ type: 'agent_started', agent: agent.name });
    
    const response = await this.llmService.streamChat(
      agent.llmConfig,
      messages,
      (chunk) => {
        onEvent({ 
          type: 'chunk', 
          agent: agent.name, 
          content: chunk.content 
        });
      }
    );
    
    // ä¿å­˜å’Œé€šçŸ¥
    await this.saveAgentResponse(agent, response);
    groupContext.addMessage(agent, response.content);
    
    onEvent({ 
      type: 'agent_completed', 
      agent: agent.name, 
      content: response.content 
    });
  }
}
```

### 3.2 è‡ªæˆ‘ä¼˜åŒ–æœºåˆ¶

```typescript
class SystemOptimizer {
  // æ”¶é›†åé¦ˆå’Œæ€§èƒ½æ•°æ®
  async collectFeedback(
    conversationId: string,
    orchestrationId: string,
    userFeedback?: UserFeedback
  ): Promise<void> {
    const metrics = {
      responseRelevance: await this.evaluateResponseRelevance(),
      conversationFlow: await this.evaluateConversationFlow(),
      userSatisfaction: userFeedback?.rating || null,
      participationBalance: await this.evaluateParticipationBalance(),
      sceneAccuracy: await this.evaluateSceneAccuracy()
    };
    
    await this.savePerformanceMetrics(orchestrationId, metrics);
  }
  
  // å®šæœŸä¼˜åŒ–ç³»ç»Ÿå‚æ•°
  async optimizeSystem(): Promise<void> {
    const recentMetrics = await this.getRecentMetrics();
    
    // ä¼˜åŒ–åœºæ™¯åˆ†æå‡†ç¡®æ€§
    await this.optimizeSceneAnalysis(recentMetrics.sceneAccuracy);
    
    // ä¼˜åŒ–æ™ºèƒ½ä½“é€‰æ‹©ç®—æ³•
    await this.optimizeAgentSelection(recentMetrics.participationBalance);
    
    // ä¼˜åŒ–æç¤ºè¯ç”Ÿæˆ
    await this.optimizePromptGeneration(recentMetrics.responseRelevance);
  }
}
```

## å››ã€æŠ€æœ¯å®ç°ç»†èŠ‚

### 4.1 æ ¸å¿ƒç±»è®¾è®¡

```typescript
// ä¸»orchestratorç±»
export class IntelligentGroupChatOrchestrator {
  private sceneAnalyzer: SceneAnalyzer;
  private orchestrationDirector: OrchestrationDirector;
  private promptFactory: DynamicPromptFactory;
  private agentScheduler: AgentScheduler;
  private systemOptimizer: SystemOptimizer;
  
  constructor() {
    this.initializeComponents();
  }
}

// åœºæ™¯åˆ†æç»“æœç±»å‹
interface SceneAnalysisResult {
  sceneType: string;
  emotionalState: string;
  topics: string[];
  socialDynamics: SocialDynamics;
  participationPlan: ParticipationSuggestion[];
  confidenceScore: number;
}

// ç¼–æ’è®¡åˆ’ç±»å‹
interface OrchestrationPlan {
  selectedAgents: AgentScore[];
  rounds: Round[];
  interactionStrategy: string;
  timingPlan: TimingPlan;
  expectedQuality: number;
}

// ç¾¤èŠä¸Šä¸‹æ–‡ç®¡ç†
class GroupChatContext {
  private conversationId: string;
  private recentMessages: Message[] = [];
  private activeParticipants: Agent[] = [];
  private conversationFlow: ConversationFlow;
  
  updateAfterMessage(agent: Agent, message: string): void {
    this.recentMessages.push({ agent, content: message, timestamp: new Date() });
    this.maintainRecentMessages(); // ä¿æŒæœ€è¿‘Næ¡æ¶ˆæ¯
    this.updateConversationFlow(agent, message);
  }
}
```

### 4.2 æ‰©å±•æ€§è®¾è®¡

#### æ–°åœºæ™¯ç±»å‹æ‰©å±•
```typescript
// åœºæ™¯æ’ä»¶æ¶æ„
interface ScenePlugin {
  sceneType: string;
  analyzer: (context: any) => Promise<boolean>; // æ˜¯å¦åŒ¹é…æ­¤åœºæ™¯
  promptEnhancer: (basePrompt: string, context: any) => Promise<string>;
  participationStrategy: (agents: Agent[], context: any) => Promise<ParticipationPlan>;
}

class ScenePluginManager {
  private plugins: Map<string, ScenePlugin> = new Map();
  
  registerPlugin(plugin: ScenePlugin): void {
    this.plugins.set(plugin.sceneType, plugin);
  }
  
  async detectScene(context: any): Promise<string[]> {
    const matches = [];
    for (const [sceneType, plugin] of this.plugins) {
      if (await plugin.analyzer(context)) {
        matches.push(sceneType);
      }
    }
    return matches;
  }
}
```

## äº”ã€å¼€å‘å®æ–½è®¡åˆ’

### ç¬¬ä¸€é˜¶æ®µ: æ ¸å¿ƒæ¶æ„æ­å»º (3-4å¤©)
- [ ] è®¾è®¡å’Œå®ç°åœºæ™¯åˆ†æAIåŸºç¡€æ¡†æ¶
- [ ] åˆ›å»ºåŠ¨æ€æç¤ºè¯å·¥å‚æ ¸å¿ƒé€»è¾‘  
- [ ] å®ç°ç¾¤èŠä¸Šä¸‹æ–‡ç®¡ç†ç³»ç»Ÿ
- [ ] æ­å»ºæ™ºèƒ½ä½“è°ƒåº¦åŸºç¡€æ¶æ„

### ç¬¬äºŒé˜¶æ®µ: åœºæ™¯åˆ†æèƒ½åŠ› (4-5å¤©)  
- [ ] è®­ç»ƒ/é…ç½®åœºæ™¯è¯†åˆ«AI
- [ ] å®ç°æƒ…æ„Ÿå’Œè¯é¢˜åˆ†æ
- [ ] å¼€å‘ç¤¾äº¤åŠ¨æ€åˆ†æ
- [ ] æ„å»ºåœºæ™¯ç½®ä¿¡åº¦è¯„ä¼°

### ç¬¬ä¸‰é˜¶æ®µ: ç¼–æ’å†³ç­–ç³»ç»Ÿ (4-5å¤©)
- [ ] å®ç°æ™ºèƒ½ä½“ç›¸å…³æ€§è¯„ä¼°ç®—æ³•
- [ ] å¼€å‘äº’åŠ¨ç­–ç•¥åˆ¶å®šé€»è¾‘
- [ ] æ„å»ºæ—¶åºè§„åˆ’ç³»ç»Ÿ
- [ ] å®ç°å†²çªæ£€æµ‹å’Œå¤„ç†

### ç¬¬å››é˜¶æ®µ: æç¤ºè¯åŠ¨æ€ç”Ÿæˆ (3-4å¤©)
- [ ] å®ç°åœºæ™¯é€‚é…æ‰©å±•ç”Ÿæˆ
- [ ] å¼€å‘è§’è‰²å®šä½åŠ¨æ€è°ƒæ•´
- [ ] æ„å»ºçº¦æŸæ¡ä»¶æ™ºèƒ½ç”Ÿæˆ
- [ ] ä¼˜åŒ–æç¤ºè¯ç»„åˆç®—æ³•

### ç¬¬äº”é˜¶æ®µ: ç³»ç»Ÿé›†æˆå’Œä¼˜åŒ– (3-4å¤©)
- [ ] é›†æˆæ‰€æœ‰ç»„ä»¶åˆ°ä¸»orchestrator
- [ ] å®ç°æ€§èƒ½ç›‘æ§å’Œåé¦ˆæ”¶é›†
- [ ] å¼€å‘è‡ªæˆ‘ä¼˜åŒ–æœºåˆ¶
- [ ] è¿›è¡Œç«¯åˆ°ç«¯æµ‹è¯•å’Œè°ƒä¼˜

### ç¬¬å…­é˜¶æ®µ: å‰ç«¯é€‚é…å’Œä½“éªŒä¼˜åŒ– (2-3å¤©)
- [ ] é€‚é…å‰ç«¯æ˜¾ç¤ºæ–°çš„äº‹ä»¶ç±»å‹
- [ ] ä¼˜åŒ–ç”¨æˆ·äº¤äº’ä½“éªŒ
- [ ] æ·»åŠ å®æ—¶çŠ¶æ€æ˜¾ç¤º
- [ ] å®ç°ç”¨æˆ·æ§åˆ¶é€‰é¡¹

## å…­ã€é¢„æœŸæ•ˆæœ

### 6.1 ç”¨æˆ·ä½“éªŒ
- **çœŸæ­£è‡ªç„¶çš„ç¾¤èŠ**: AIä»¬æ ¹æ®åœºæ™¯è‡ªä¸»å†³å®šå‚ä¸æ–¹å¼
- **ä¸ªæ€§é²œæ˜**: æ¯ä¸ªAIä¿æŒç‹¬ç‰¹ä¸ªæ€§åŒæ—¶é€‚åº”åœºæ™¯
- **æ™ºèƒ½é€‚åº”**: ç³»ç»Ÿå­¦ä¹ ç”¨æˆ·åå¥½ï¼Œè¶Šæ¥è¶Šè´´åˆéœ€æ±‚
- **æ— é™æ‰©å±•**: å¯ä»¥è½»æ¾æ·»åŠ æ–°åœºæ™¯å’Œæ–°çš„äº’åŠ¨æ¨¡å¼

### 6.2 æŠ€æœ¯ç‰¹è‰²
- **AIé©±åŠ¨çš„AIç¼–æ’**: çœŸæ­£çš„æ™ºèƒ½åŒ–ç³»ç»Ÿ
- **åŠ¨æ€è‡ªé€‚åº”**: æ— éœ€é¢„è®¾è§„åˆ™ï¼Œè‡ªä¸»å­¦ä¹ ä¼˜åŒ–
- **é«˜åº¦æ¨¡å—åŒ–**: æ¯ä¸ªç»„ä»¶éƒ½å¯ç‹¬ç«‹å‡çº§æ›¿æ¢
- **æ•°æ®é©±åŠ¨ä¼˜åŒ–**: åŸºäºå®é™…è¡¨ç°æŒç»­æ”¹è¿›

è¿™ä¸ªæ–¹æ¡ˆå½»åº•æŠ›å¼ƒäº†å›ºå®šæ¨¡å¼çš„é™åˆ¶ï¼Œæ„å»ºäº†ä¸€ä¸ªçœŸæ­£æ™ºèƒ½ã€è‡ªé€‚åº”çš„ç¾¤èŠç³»ç»Ÿã€‚æ¯æ¬¡å¯¹è¯éƒ½æ˜¯ç‹¬ç‰¹çš„ï¼ŒAIä»¬ä¼šæ ¹æ®å®æ—¶æƒ…å†µåšå‡ºæœ€åˆé€‚çš„ååº”ã€‚